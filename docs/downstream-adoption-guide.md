# Downstream Adoption Guide

> The comprehensive guide for teams and AI agents building downstream repos
> on the ripple-next golden path. Covers greenfield projects, legacy
> migrations, and ongoing compliance.
>
> See [ADR-023](./adr/023-downstream-adoption-standards.md) for the decision
> rationale. See [Platform Capabilities](./platform-capabilities.md) for what
> ripple-next provides.

---

## Who This Guide Is For

- **AI agents** scaffolding and building downstream repos (primary audience)
- **Development teams** adopting ripple-next conventions
- **Tech leads** planning downstream architecture and migration

---

## Quick Start

### Greenfield (New Project)

```bash
# 1. Scaffold
pnpm generate:scaffold /path/to/repo --name=my-project --org=my-org

# 2. Follow the adoption runbook
pnpm runbook adopt-ripple-next

# 3. Verify
pnpm conform -- --target=/path/to/repo
```

### Legacy Migration (Existing API/Service)

```bash
# 1. Scaffold
pnpm generate:scaffold /path/to/repo --name=my-project --org=my-org

# 2. Follow the migration runbook
pnpm runbook migrate-legacy-api

# 3. Verify
pnpm conform -- --target=/path/to/repo
```

---

## What You Must Produce

Every downstream repo must produce documentation in these 7 categories.
Governance is advisory (report only, does not block CI) — see [ADR-023](./adr/023-downstream-adoption-standards.md).

### 1. Product Roadmap (Required)

**Location:** `docs/product-roadmap/README.md`

**Structure:** Now/Next/Later timeline with numbered items.

Must include:
- Numbered items using a project-specific prefix (e.g., `MY-001`, `GOV-001`)
- Status per item: Planned, In Progress, Done, Blocked
- Now/Next/Later timeline sections
- At minimum 3 items describing current work
- Risks & Unknowns table
- AI-first benefit rationale per item (one sentence)

Do NOT:
- Leave the scaffold placeholder checkboxes
- Use undated `Phase 1` / `Phase 2` structure — use `Now` / `Next` / `Later`
- Mix roadmap with technical implementation notes

**Example item format:**

```markdown
### MY-001: User Authentication Integration

**Status:** In Progress
**Priority:** Critical | **Impact:** High | **Effort:** Medium
**AI-first benefit:** Enables agents to scaffold auth-protected routes deterministically.

- [ ] Configure OIDC provider
- [ ] Implement login/logout flow
- [ ] Add session management
```

### 2. Architecture Documentation (Required)

**Location:** `docs/architecture.md`

Must include:
- **System overview** — Mermaid diagram showing components and their relationships
- **Stack table** — layer, technology, which `@ripple-next/*` packages consumed, relevant ADRs
- **Provider pattern usage** — which providers, which implementations per environment (test/local/prod)
- **Compute decisions** — Lambda vs ECS choices made and why
- **Data model overview** — if the project has a database
- **Deviations from golden path** — any intentional differences from ripple-next conventions and why
- Links to relevant ADRs

### 3. API Contract Documentation (Required if repo has API endpoints)

**Location:** `docs/api-contracts.md`

Must include:
- **Endpoint table** — procedure/method, HTTP method, path, visibility (public/internal), auth requirement, description
- **OpenAPI spec location** — if using oRPC: generated at `docs/api/openapi.json`
- **Contract testing approach** — how API contracts are validated
- **Breaking change policy** — versioning strategy, deprecation procedure

For oRPC repos:
- `pnpm generate:openapi` to generate spec
- `pnpm check:api-contract` for drift detection
- `pnpm check:api-breaking` for breaking change detection

For non-oRPC repos:
- Manual OpenAPI spec or endpoint table at minimum
- Document: method, path, request schema, response schema

### 4. Architecture Decision Records (Required, minimum 2)

**Location:** `docs/adr/`

Must include:
- **ADR-001: Record Architecture Decisions** — generated by scaffold
- **At least one additional ADR** for the project's most significant architecture decision (e.g., "Why we chose oRPC over REST", "Why we use the queue provider for async processing")

Follow the [ADR conventions](./adr/README.md): Status, Context, Decision, Consequences. ADRs are numbered sequentially and never deleted.

### 5. Readiness Manifest (Required)

**Location:** `docs/readiness.json`

Must include:
- **Real subsystems** — replace the scaffold `example` placeholder with actual project subsystems
- **Status per subsystem** — `planned`, `in-progress`, `implemented`
- **Maturity per subsystem** — `interface-defined`, `conformance-tested`, `integration-tested`, `production-proven`
- **Blockers** — documented for each subsystem
- **Test coverage** — description of testing approach per subsystem

### 6. README.md (Required)

Must include:
- **Project purpose** — what this repo does and why it exists
- **Setup instructions** — prerequisites, install, run
- **Architecture overview** — brief summary or link to `docs/architecture.md`
- **Links to key docs** — roadmap, architecture, API contracts

### 7. CLAUDE.md (Required)

Must include:
- **Verify command** — `pnpm verify` (or equivalent)
- **Lint rules** — project-specific lint configuration highlights
- **Key patterns** — architecture patterns specific to this project
- **Auto-imports** — if using Nuxt, document what's auto-imported vs manual

Follow [ADR-020](./adr/020-context-file-minimalism.md): keep it minimal (~40 lines), only hard constraints that cause CI failures if unknown.

---

## Greenfield Adoption Path

### Step 1: Scaffold

```bash
pnpm generate:scaffold /path/to/repo --name=my-project --org=my-org
```

This creates ~35+ files: AI docs, quality gates, CI workflows, fleet governance,
documentation templates. See [Platform Capabilities](./platform-capabilities.md#code-generators).

### Step 2: Configure

```bash
cd /path/to/repo
cp .env.example .env
```

- Update `.github/CODEOWNERS` with your team
- Customise `CLAUDE.md` and `AGENTS.md` for your project
- Review and adjust `eslint.config.js` if needed

### Step 3: Install Packages

```bash
# Set up private registry (see developer-guide.md for registry setup)
pnpm add @ripple-next/validation @ripple-next/shared

# Add packages based on your needs:
# Auth:     pnpm add @ripple-next/auth
# Database: pnpm add @ripple-next/db
# Queue:    pnpm add @ripple-next/queue
# Storage:  pnpm add @ripple-next/storage
# Email:    pnpm add @ripple-next/email
# Events:   pnpm add @ripple-next/events
# UI:       pnpm add @ripple-next/ui
# CMS:      pnpm add @ripple-next/cms
# Testing:  pnpm add -D @ripple-next/testing
```

### Step 4: Implement

- Use the **provider pattern** for all infrastructure concerns ([Provider Pattern](./provider-pattern.md))
- Use **oRPC** for API endpoints ([API Contracts](./api-contracts.md), [ADR-021](./adr/021-api-contract-strategy.md))
- Use **Drizzle ORM** via `@ripple-next/db` for database access
- Use the **repository pattern** for all database access
- Tests always use mock/memory providers — never cloud services
- Follow the **compute decision framework**: Lambda default, ECS escape hatch ([Lambda vs ECS](./lambda-vs-ecs.md))

### Step 5: Document

Complete all 7 documentation categories listed above:

1. Replace the scaffold product roadmap with real Now/Next/Later items
2. Create `docs/architecture.md` with system overview and stack table
3. Create `docs/api-contracts.md` (if the repo has API endpoints)
4. Write at least one ADR beyond ADR-001
5. Update `docs/readiness.json` with real subsystems
6. Update `README.md` with project purpose and setup
7. Customise `CLAUDE.md` with project-specific constraints

### Step 6: Verify

```bash
# Run conformance scoring
pnpm conform -- --target=/path/to/repo --json

# Check fleet compliance
pnpm check:fleet-drift -- --target=/path/to/repo

# Run quality gates
cd /path/to/repo && pnpm verify
```

### Step 7: Deploy

Follow the [Deployment Guide](./deployment.md) and [Lambda vs ECS](./lambda-vs-ecs.md)
for compute decisions. Use SST v3 for infrastructure ([ADR-004](./adr/004-sst-over-cdk.md)).

---

## Legacy Migration Path

When migrating existing APIs or services (e.g., Mule 3, .NET, Java, Express)
into ripple-next conventions.

### Phase 1: Analyze

**Goal:** Understand what you're migrating.

1. **Inventory all endpoints** — method, path, auth model, request/response schemas
2. **Identify data models** — database schemas, entity relationships, data types
3. **Document integration points** — upstream dependencies, downstream consumers, webhooks
4. **Capture edge cases** — undocumented behaviours, coercions, defaults, error formats
5. **Classify each endpoint:**
   - **Migrate** — move to ripple-next with parity
   - **Deprecate** — remove (no consumers depend on it)
   - **Bridge** — temporary proxy during transition period

### Phase 2: Scaffold

```bash
pnpm generate:scaffold /path/to/repo --name=my-migrated-api --org=my-org
```

Configure for the specific migration context. Install the packages you'll need.

### Phase 3: Model

1. **Map legacy data models** to Drizzle ORM schemas in `packages/db/schema/`
2. **Create Zod validation schemas** in `packages/validation/` for each endpoint
3. **Map legacy auth** to the OIDC provider pattern ([ADR-008](./adr/008-oidc-over-lucia.md))
4. Use `MockAuthProvider` in tests, `OidcAuthProvider` in production

### Phase 4: Contract

1. **Create target OpenAPI spec** matching legacy endpoints
2. For each endpoint, document in `docs/migration-notes.md`:
   - **Current contract (as-is)** — legacy endpoint behaviour
   - **Target contract (to-be)** — ripple-next endpoint behaviour
   - **Migration notes** — breaking changes, field renames, type changes
3. **Generate oRPC routers** matching the target contract
4. Run `pnpm generate:openapi` to produce the spec

### Phase 5: Implement

1. **Implement each migrated endpoint** using oRPC + provider pattern + repository pattern
2. Use **memory providers** for all tests
3. Follow the **provider pattern** for infrastructure concerns
4. Implement **error mapping** — translate legacy error formats to standard responses

### Phase 6: Verify Parity

1. **Write parity tests** comparing legacy and new API responses
2. Cover: success paths, validation failures, error cases, edge cases
3. **Side-by-side response comparison** where possible
4. Verify: status codes, response schemas, field names, null/empty behaviour
5. Run `pnpm test` — all parity tests must pass

### Phase 7: Document

Complete all 7 documentation categories plus:

- **`docs/migration-notes.md`** — legacy-to-new endpoint mapping
- **ADR** documenting the migration decision and approach
- **Update `readiness.json`** with migrated subsystem statuses
- **Product roadmap** — include legacy system sunset timeline

---

## Provider Pattern Adoption

Every infrastructure concern must use the provider pattern ([ADR-003](./adr/003-provider-pattern.md)).

**When to use a provider:**
- Authentication → `@ripple-next/auth` (MockAuthProvider / OidcAuthProvider)
- File storage → `@ripple-next/storage` (FilesystemStorageProvider / MinioStorageProvider / S3StorageProvider)
- Email → `@ripple-next/email` (MemoryEmailProvider / SmtpEmailProvider / SesEmailProvider)
- Queue → `@ripple-next/queue` (MemoryQueueProvider / BullMQQueueProvider / SqsQueueProvider)
- Events → `@ripple-next/events` (MemoryEventBus / EventBridgeBus)
- CMS → `@ripple-next/cms` (MockCmsProvider / DrupalCmsProvider)

**Rules:**
- Tests **always** use memory/mock providers — never cloud services
- New provider implementations **must** pass the conformance suite from `@ripple-next/testing`
- Use `pnpm generate:provider <Name> --concern=<concern>` to scaffold

See [Provider Pattern](./provider-pattern.md) for implementation details.

---

## Conformance Requirements

Downstream repos are scored against the [conformance rubric](./conformance-rubric.json):

| Category | Weight | What It Checks |
|----------|--------|---------------|
| Setup & Toolchain | 20 | .nvmrc, packageManager, engines, .env.example |
| Quality Gates | 20 | ESLint, TypeScript, Prettier, verify script |
| CI/CD Pipeline | 20 | ci.yml, security.yml, CODEOWNERS |
| Testing | 15 | Test framework, test script, env validation |
| Documentation | 7 | README.md, CLAUDE.md, readiness.json |
| Security & Licensing | 10 | SPDX license, LICENSE file, .env gitignored |
| Fleet Governance | 3 | .fleet.json exists |
| Downstream Documentation | 5 | Product roadmap, architecture, API contracts |

**Passing threshold:** 70/100. Run `pnpm conform -- --target=/path/to/repo --json`.

---

## Fleet Governance

Downstream repos are monitored for compliance via fleet governance ([ADR-019](./adr/019-fleet-governance.md)):

- **13 governed surfaces** across 3 severity levels
- **Drift detection:** `pnpm check:fleet-drift -- --target=/path/to/repo`
- **Sync:** `pnpm fleet:sync -- --target=/path/to/repo`
- **Feedback:** `pnpm fleet:feedback -- --type=<type> --title="..." --submit`

Documentation surfaces (FLEET-SURF-012, FLEET-SURF-013) are **advisory** — they
report gaps but don't block CI. This allows downstream repos to adopt incrementally.

**Exception workflow:** Inline comments with 90-day expiry:
```
// fleet-policy-exception: FLEET-SURF-012 — documentation deferred until MVP complete
```

See [`fleet-policy.json`](./fleet-policy.json) and [Downstream Workflows](./downstream-workflows.md) for operational details.

---

## Related Documentation

- [Platform Capabilities](./platform-capabilities.md) — what ripple-next provides
- [Downstream Workflows](./downstream-workflows.md) — CI consumption and fleet operations
- [Developer Guide](./developer-guide.md) — consumer app setup (frontend, backend, full-stack)
- [Architecture](./architecture.md) — ripple-next system architecture
- [Provider Pattern](./provider-pattern.md) — core infrastructure abstraction
- [API Contracts](./api-contracts.md) — oRPC and REST endpoints
- [Testing Guide](./testing-guide.md) — test pyramid and examples
- [Conformance Rubric](./conformance-rubric.json) — scoring criteria
- [Fleet Policy](./fleet-policy.json) — governed surfaces
- [ADR-023](./adr/023-downstream-adoption-standards.md) — decision rationale
